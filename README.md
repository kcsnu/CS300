### What was the problem you were solving in the projects for this course?

The problem I was solving in the projects was how to help academic advisors at ABCU manage and share information about Computer Science courses more easily. I created a software tool that could load course data from a file, list all the courses in alphabetical order, and show details and prerequisites for any course the user selects. The project had two parts: first, I designed the data structure and algorithm, and then I built a working C++ program that runs in the command line. This helped me practice both planning and programming skills.

### How did you approach the problem? Consider why data structures are important to understand.

To solve the problem, I started by analyzing the project requirements and identifying key features like loading course data, searching for specific courses, and printing them in order. I looked at different data structures, like vectors, hash tables, and binary search trees, to figure out which would work best. I wrote pseudocode and compared how each option would perform in terms of speed and memory use. Choosing the right data structure is important because it affects how well the program runs and how easy it is to maintain. For this project, I decided that a balanced binary search tree was the best choice because it allowed for fast course lookups and easy sorting when printing the course list.

### How did you overcome any roadblocks you encountered while going through the activities or project?

Some of the main challenges I faced were making sure the program handled bad input correctly, like missing course data or invalid prerequisites, and dealing with case-insensitive course numbers. I also had to make sure the courses printed in the correct alphabetical order using an efficient in-order traversal. To overcome these problems, I broke the code into smaller, manageable functions and added error checks throughout the program. I also used C++ reference materials and online resources to better understand the syntax and how to use standard library features. Testing the program with different sample data files helped me catch and fix edge cases I hadnâ€™t thought of at first.

### How has your work on this project expanded your approach to designing software and developing programs?

Working on these projects taught me how important it is to plan and design before starting to code. I learned that choosing the right data structure and thinking through the algorithm ahead of time makes the final program faster and easier to maintain. Writing pseudocode and analyzing how long things would take to run helped me create better code overall. Now, I spend more time on upfront planning and breaking the program into smaller parts, which makes it easier to update or change later if needed.

### How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?

This project helped me become more careful about writing clean and organized code. I got better at using clear variable and function names, keeping my indentation consistent, and adding helpful comments. I also learned how useful it is to write modular code by putting related logic into classes and functions. This makes the code easier to understand and change later on. By following these best practices, I feel more confident writing code that others can read and maintain and that I can come back to and improve in the future.
